<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PROFASI: prf::Update Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceprf.html">prf</a>::<a class="el" href="classprf_1_1Update.html">Update</a>
  </div>
</div>
<div class="contents">
<h1>prf::Update Class Reference<br/>
<small>
[<a class="el" href="group__profasi__updates.html">Conformational Updates</a>]</small>
</h1><!-- doxytag: class="prf::Update" --><!-- doxytag: inherits="prf::Named" -->
<p>The base class for all conformational updates.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Update.hh&gt;</code></p>

<p>Inherits <a class="el" href="classprf_1_1Named.html">prf::Named</a>.</p>

<p>Inherited by <a class="el" href="classprf_1_1BGS.html">prf::BGS</a>, <a class="el" href="classprf_1_1Pivot.html">prf::Pivot</a>, <a class="el" href="classprf_1_1Rot.html">prf::Rot</a>, <a class="el" href="classprf_1_1Rotation.html">prf::Rotation</a>, and <a class="el" href="classprf_1_1Translation.html">prf::Translation</a>.</p>

<p><a href="classprf_1_1Update-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ba54ecb2fa9f0430141eac4a94cca0"></a><!-- doxytag: member="prf::Update::set_RandomNumberGenerator" ref="ad7ba54ecb2fa9f0430141eac4a94cca0" args="(RandomNumberBase *rn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#ad7ba54ecb2fa9f0430141eac4a94cca0">set_RandomNumberGenerator</a> (<a class="el" href="classprf_1_1RandomNumberBase.html">RandomNumberBase</a> *rn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An update needs a random number generator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a061422ac00194525b4eb8b52058b2741"></a><!-- doxytag: member="prf::Update::set_sequencial_sweep" ref="a061422ac00194525b4eb8b52058b2741" args="(bool sw=true)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a061422ac00194525b4eb8b52058b2741">set_sequencial_sweep</a> (bool sw=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep through the DOFs sequencially rather than randomly. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d771e80fdccf1c11c6049117c80570"></a><!-- doxytag: member="prf::Update::connect" ref="ab5d771e80fdccf1c11c6049117c80570" args="(Population *pl)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#ab5d771e80fdccf1c11c6049117c80570">connect</a> (<a class="el" href="classprf_1_1Population.html">Population</a> *pl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An update must be connected with a population. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26693e4579f1dc7adcc3e0a1dbdacae3"></a><!-- doxytag: member="prf::Update::init" ref="a26693e4579f1dc7adcc3e0a1dbdacae3" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a26693e4579f1dc7adcc3e0a1dbdacae3">init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize update for use. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d90007e131d24c152091dfa2e94fcbd"></a><!-- doxytag: member="prf::Update::perform" ref="a0d90007e131d24c152091dfa2e94fcbd" args="(int itm)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a0d90007e131d24c152091dfa2e94fcbd">perform</a> (int itm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a move in the conformation space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bb6d33f7bfe87be43ceb492ac651c24"></a><!-- doxytag: member="prf::Update::accept" ref="a2bb6d33f7bfe87be43ceb492ac651c24" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a2bb6d33f7bfe87be43ceb492ac651c24">accept</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes a proposed update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a521806f8d8eeafc68604331b9c9d38d7"></a><!-- doxytag: member="prf::Update::revert" ref="a521806f8d8eeafc68604331b9c9d38d7" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a521806f8d8eeafc68604331b9c9d38d7">revert</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverts the proposed update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83b6980397f35c35b2f4f6302fb33f0c"></a><!-- doxytag: member="prf::Update::print_setup" ref="a83b6980397f35c35b2f4f6302fb33f0c" args="(std::string &amp;st)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a83b6980397f35c35b2f4f6302fb33f0c">print_setup</a> (std::string &amp;st)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print info about any departure from default behaviour. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modulating the behaviour of updates</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf3abf090104f771ff0c1a1bbd8a5c830"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9667ff31109971d0d5549bc023cf134"></a><!-- doxytag: member="prf::Update::n_relevant_dof" ref="ad9667ff31109971d0d5549bc023cf134" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#ad9667ff31109971d0d5549bc023cf134">n_relevant_dof</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of DOF in the system which may be touched by the update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a6caf6af325c1cc9a53f0b1266c85d1e6">get_weight_of_dof</a> (int idof)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Weight of a particular DOF.  <a href="#a6caf6af325c1cc9a53f0b1266c85d1e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a4861658f70e2978858652072a7c7ec48">set_weight_of_dof</a> (int idof, double vl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set weight of a DOF.  <a href="#a4861658f70e2978858652072a7c7ec48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea405c01cf548ff0e9b4e2db22088e96"></a><!-- doxytag: member="prf::Update::configure" ref="aea405c01cf548ff0e9b4e2db22088e96" args="(prf_xml::XML_Node *nd)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#aea405c01cf548ff0e9b4e2db22088e96">configure</a> (<a class="el" href="classprf__xml_1_1XML__Node.html">prf_xml::XML_Node</a> *nd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure update using options provided in an XML node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#aa5e461c909338b4839ced9c6f918be1d">get_site_of_dof</a> (<a class="el" href="classprf_1_1DOF__Info.html">DOF_Info</a> &amp;dof)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get site index of a given DOF  <a href="#aa5e461c909338b4839ced9c6f918be1d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Update categories</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc8641578fef63ba16fec42502ff46fb4"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a213019c9f4089bf659242de63b5001ec"></a><!-- doxytag: member="prf::Update::sidechain_update" ref="a213019c9f4089bf659242de63b5001ec" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>sidechain_update</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73cef2482a0a52d1cf5f1902d9c6a998"></a><!-- doxytag: member="prf::Update::rigid_chain_update" ref="a73cef2482a0a52d1cf5f1902d9c6a998" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>rigid_chain_update</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa197c859a6b04d88fa540184c17c0194"></a><!-- doxytag: member="prf::Update::backbone_update" ref="aa197c859a6b04d88fa540184c17c0194" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>backbone_update</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a817afb3a713a3413bedf52acb0b71070"></a><!-- doxytag: member="prf::Update::multichain_update" ref="a817afb3a713a3413bedf52acb0b71070" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>multichain_update</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02dc57168fb9f111556d8e99f5671a9e"></a><!-- doxytag: member="prf::Update::local_update" ref="a02dc57168fb9f111556d8e99f5671a9e" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_update</b> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">So, what changed ?</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp71b56e676fbc5d09728fb9acc113cbc3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad529251b698d07cd0ab3faf6c1e3859a"></a><!-- doxytag: member="prf::Update::num_changes" ref="ad529251b698d07cd0ab3faf6c1e3859a" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><b>num_changes</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee87fa12fac1bff25c0a32bc581b09a1"></a><!-- doxytag: member="prf::Update::change" ref="aee87fa12fac1bff25c0a32bc581b09a1" args="(unsigned i)" -->
<a class="el" href="structprf_1_1dof__change__type.html">dof_change_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>change</b> (unsigned i)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Ranges of changed things</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp91bc0fb46f645714b03f05c332eefd35"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d4d9e417230bf6a031d25b22144a64e"></a><!-- doxytag: member="prf::Update::current_atoms" ref="a1d4d9e417230bf6a031d25b22144a64e" args="(int &amp;istr, int &amp;iend)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a1d4d9e417230bf6a031d25b22144a64e">current_atoms</a> (int &amp;istr, int &amp;iend)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first and last atoms affected by the update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6a64344563c28a2285527881d38d0fb"></a><!-- doxytag: member="prf::Update::begin_atom" ref="af6a64344563c28a2285527881d38d0fb" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#af6a64344563c28a2285527881d38d0fb">begin_atom</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">First affected atom. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a767f05303e87d4088639e5cdbc48b002"></a><!-- doxytag: member="prf::Update::end_atom" ref="a767f05303e87d4088639e5cdbc48b002" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a767f05303e87d4088639e5cdbc48b002">end_atom</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One past the last atom, like the end() in standard containers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a33e1f0c87148cdaf0ac4ae5a733b3ba5">begin_flexible_part</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start of the flexible part of the update.  <a href="#a33e1f0c87148cdaf0ac4ae5a733b3ba5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf5933558ece9e46449a1a634d93423c"></a><!-- doxytag: member="prf::Update::end_flexible_part" ref="acf5933558ece9e46449a1a634d93423c" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#acf5933558ece9e46449a1a634d93423c">end_flexible_part</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End of the flexible part, once again, one past the last ... <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a671499385748c62add9238d700ad51ab">intrinsic_weight</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Additional weight for Metropolis-Hastings updates.  <a href="#a671499385748c62add9238d700ad51ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a554c2e7257f780b012dbdcb9ec991337">n_residue_rigid_ranges</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes list of ranges of changed residues.  <a href="#a554c2e7257f780b012dbdcb9ec991337"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a10b1116f0f713c3705a24027354b1759">residue_rigid_range</a> (int i, int &amp;r1, int &amp;r2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i'th rigid range returned as ligand indices in r1 and r2  <a href="#a10b1116f0f713c3705a24027354b1759"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6754627750ccb796e432b05ecab0b523"></a><!-- doxytag: member="prf::Update::residue_rigid_ranges" ref="a6754627750ccb796e432b05ecab0b523" args="()" -->
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
int &gt; &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Update.html#a6754627750ccb796e432b05ecab0b523">residue_rigid_ranges</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the vector of rigid ranges. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae20ca018724d05e64835cb77d32e692a"></a><!-- doxytag: member="prf::Update::n_atom_rigid_ranges" ref="ae20ca018724d05e64835cb77d32e692a" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>n_atom_rigid_ranges</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacfa9ef5bbdc0150abd40e0b4e3e0236"></a><!-- doxytag: member="prf::Update::atom_rigid_range" ref="aacfa9ef5bbdc0150abd40e0b4e3e0236" args="(int i, int &amp;r1, int &amp;r2)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom_rigid_range</b> (int i, int &amp;r1, int &amp;r2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78d3eaf163d9a83bca9395ce034eea19"></a><!-- doxytag: member="prf::Update::atom_rigid_ranges" ref="a78d3eaf163d9a83bca9395ce034eea19" args="()" -->
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
int &gt; &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom_rigid_ranges</b> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>In this class we define the interface that every conformational update in PROFASI must have. The individual updates, like bgs for instance, would over-ride the virtual functions, and define exactly what happens when that update is invoked. But having a common interface facillitates integration with the rest of the package. For instance, the <a class="el" href="classprf_1_1MC.html" title="MC class handles the Markov Chain Monte Carlo evolution.">MC</a> class makes a vector of Update's and calls the functions perform(), <a class="el" href="classprf_1_1Update.html#a2bb6d33f7bfe87be43ceb492ac651c24" title="Finalizes a proposed update.">accept()</a> or reject() on the <a class="el" href="classprf_1_1Update.html" title="The base class for all conformational updates.">Update</a> object.</p>
<p>In other words, <a class="el" href="classprf_1_1Update.html" title="The base class for all conformational updates.">Update</a> is an abstract concept... something happens to the system conformation. That is all that is required to define the behaviour of the Markov Chain generators. So, all such classes which only require an abstract interface, make use of this base class, and invoke <a class="el" href="classprf_1_1Update.html" title="The base class for all conformational updates.">Update</a> objects through pointers. A real application on the other hand, will not define abstract Updates but rather objects of the derived classes. But a pointer to an <a class="el" href="classprf_1_1Update.html" title="The base class for all conformational updates.">Update</a> can also point to an object of a derived class. This way, the implementation of the <a class="el" href="classprf_1_1MC.html" title="MC class handles the Markov Chain Monte Carlo evolution.">MC</a> class or its derivatives can be kept separate from the details and finer points of individual conformational updates. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a33e1f0c87148cdaf0ac4ae5a733b3ba5"></a><!-- doxytag: member="prf::Update::begin_flexible_part" ref="a33e1f0c87148cdaf0ac4ae5a733b3ba5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int prf::Update::begin_flexible_part </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the update moves a section of the system in which lots of atoms move non-rigidly wrt eachother, we define a "flexible_part". </p>

</div>
</div>
<a class="anchor" id="aa5e461c909338b4839ced9c6f918be1d"></a><!-- doxytag: member="prf::Update::get_site_of_dof" ref="aa5e461c909338b4839ced9c6f918be1d" args="(DOF_Info &amp;dof)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t prf::Update::get_site_of_dof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf_1_1DOF__Info.html">DOF_Info</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dof</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Search and return the site index of a certain DOF. If the DOF is not in the domain of the update, the size of the dof_at_site array is returned. </p>

</div>
</div>
<a class="anchor" id="a6caf6af325c1cc9a53f0b1266c85d1e6"></a><!-- doxytag: member="prf::Update::get_weight_of_dof" ref="a6caf6af325c1cc9a53f0b1266c85d1e6" args="(int idof)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::Update::get_weight_of_dof </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idof</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The input argument is the unique id of a DOF. The output is 0 if the DOF will never be touched: like if the DOF is a sidechain angle and the update is a purely backbone update. Otherwise, it is the relative weight of the DOF compared to other DOFs in the domain of the update. Appart from a normalising factor, this corresponds to the number of times a certain DOF is updated in a sweep. </p>

</div>
</div>
<a class="anchor" id="a671499385748c62add9238d700ad51ab"></a><!-- doxytag: member="prf::Update::intrinsic_weight" ref="a671499385748c62add9238d700ad51ab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::Update::intrinsic_weight </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PROFASI provides a method to use a corrective weight for an update on top of what would be used in a pure Metropolis step. Such a weight is required if the probabilities for the size of the update somehow depend on the starting conformation, so that the forward and backward processes would have would have different distributions. In order to ensure detail balance, one needs to introduce an additional weight that compensates for the above. In PROFASI, only <a class="el" href="classprf_1_1BGS.html" title="Biased Gaussian Steps.">BGS</a> has that kind of a weight. But the provision is made more generally to smoothen the interface and allow for more updates like the <a class="el" href="classprf_1_1BGS.html" title="Biased Gaussian Steps.">BGS</a> in the future. The corrective weight is called IntrinsicWeight. </p>

<p>Reimplemented in <a class="el" href="classprf_1_1BGS.html#a7b1a2b790bbdba13ca9800f3cd03a7a6">prf::BGS</a>.</p>

</div>
</div>
<a class="anchor" id="a554c2e7257f780b012dbdcb9ec991337"></a><!-- doxytag: member="prf::Update::n_residue_rigid_ranges" ref="a554c2e7257f780b012dbdcb9ec991337" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int prf::Update::n_residue_rigid_ranges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Each range returned represents a set of residues which have moved in a rigid manner relative to each other. </p>

</div>
</div>
<a class="anchor" id="a10b1116f0f713c3705a24027354b1759"></a><!-- doxytag: member="prf::Update::residue_rigid_range" ref="a10b1116f0f713c3705a24027354b1759" args="(int i, int &amp;r1, int &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::Update::residue_rigid_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>r2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An update can divide the system into many segments which move rigidly with respect to the rest of the system. Since the degrees of freedom in PROFASI are only the torsional angles, it is most often the case that there are indeed only a few subsystems that move rigidly with respect to the rest. Most easy to visualize is a rigid body translation of a single chain relative to the rest. But also when a torsional angle is changed, two parts of the system move rigidly with respect to each other about the axis of that torsional angle.</p>
<p>Here, the ranges returned are not the atomic ranges, but rather at the level of residues, or ligands, relative to the entire system.</p>
<p>The following convention is used here, and is important in the design of new updates: If a range contains more than one ligand, atoms in one ligand have a fixed distance with respect to all atoms in the other ligands covered in the range. If the range contains only one ligand, no such restriction is assumed. That is, atoms inside that ligand can change distance between each other. Such single ligand ranges must be used for residues in which one or more degrees of freedom have changed. Longer ranges can only be used for residues in which no internal degrees of freedom have changed.</p>
<p>The ranges are inclusive at both the left and the right, meaning, a range of (2,5) would include residues 2,3,4,5 as a rigidly moving block.</p>
<p>It is further assumed that the ranges are arranged in increasing ligand indices, and are mutually non-overlapping, and are non-degenerate, meaning they always contain at-least one residue. </p>

</div>
</div>
<a class="anchor" id="a4861658f70e2978858652072a7c7ec48"></a><!-- doxytag: member="prf::Update::set_weight_of_dof" ref="a4861658f70e2978858652072a7c7ec48" args="(int idof, double vl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::Update::set_weight_of_dof </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the DOF is in the domain of an update, this changes the probability that it is selected for a move. All DOFs in the domain are given a weight 1 by default, which means that they will be updated with equal probability. If a DOF is given a higher weight, it will be favoured. Normalisation is taken care off internally. Like get_weight_of_dof, the input argument is the global unique id of a DOF. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/Updates/Update.hh</li>
<li>model/Updates/Update.cc</li>
</ul>
</div>
<center>
<hr>
<small>
<strong>PROFASI: Protein Folding and Aggregation Simulator, Version 1.5 
</strong><br />
&copy; (2005-2009) <a href="http://www.thep.lu.se/~anders">Anders Irb&auml;ck</a>
and <a href="http://www.thep.lu.se/~sandipan">Sandipan Mohanty</a><br />
Documentation generated on 19 Jun 2014 using Doxygen version 1.6.1
</small>
</center>

</body>
</html> 
