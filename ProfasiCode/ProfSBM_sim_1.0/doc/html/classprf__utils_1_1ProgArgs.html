<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PROFASI: prf_utils::ProgArgs Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceprf__utils.html">prf_utils</a>::<a class="el" href="classprf__utils_1_1ProgArgs.html">ProgArgs</a>
  </div>
</div>
<div class="contents">
<h1>prf_utils::ProgArgs Class Reference<br/>
<small>
[<a class="el" href="group__utilities.html">Utilities</a>]</small>
</h1><!-- doxytag: class="prf_utils::ProgArgs" -->
<p>A utility to help manage program parameters.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ProgUtils.hh&gt;</code></p>

<p><a href="classprf__utils_1_1ProgArgs-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50aece153cdca3e1ce12338212c90150"></a><!-- doxytag: member="prf_utils::ProgArgs::ProgArgs" ref="a50aece153cdca3e1ce12338212c90150" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a50aece153cdca3e1ce12338212c90150">ProgArgs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a9317a4b392037c0813ba0c1b06c682d9">option</a> (std::string longname, std::string shortname, int nargus, std::string helptext=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare a new option with some specified properties.  <a href="#a9317a4b392037c0813ba0c1b06c682d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ae9a8dec1c3df8de1f6f7a30d4af4fd71">new_switch</a> (std::string longname, std::string shortname, bool defstate=true, std::string helptext=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new program switch.  <a href="#ae9a8dec1c3df8de1f6f7a30d4af4fd71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a75ff8d4192e9efe47280e8dd355cd1e2">init_options</a> (int argc, char *argv[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get options from command line and settings files.  <a href="#a75ff8d4192e9efe47280e8dd355cd1e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::list&lt; InstructionString &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a04eeeb9f21830a1a77c12da5db4acc39">get_options</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of all instructions in command line and settings files.  <a href="#a04eeeb9f21830a1a77c12da5db4acc39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ab5e75ce45f27d6bd45f0d5bf1488eca2">analyze</a> (int argc, char *argv[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analyze the command line to find given options.  <a href="#ab5e75ce45f27d6bd45f0d5bf1488eca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#aacdad11b8e68dc732a94cd21fba74249">n_spare_args</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of left over arguments on the command line.  <a href="#aacdad11b8e68dc732a94cd21fba74249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14daea375e543e3d136574c765608a99"></a><!-- doxytag: member="prf_utils::ProgArgs::spare_args" ref="a14daea375e543e3d136574c765608a99" args="(int i)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a14daea375e543e3d136574c765608a99">spare_args</a> (int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i'th left over argument <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#af446793145edb05da55a002e1378d713">write_available</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List available options.  <a href="#af446793145edb05da55a002e1378d713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ad4fe85a2d39442ba8526fc9148dd6332">disable</a> (std::string opnname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an option even if it is recognized.  <a href="#ad4fe85a2d39442ba8526fc9148dd6332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f766049ee728ddf78e42028dd48ab60"></a><!-- doxytag: member="prf_utils::ProgArgs::enable" ref="a2f766049ee728ddf78e42028dd48ab60" args="(std::string opnname)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a2f766049ee728ddf78e42028dd48ab60">enable</a> (std::string opnname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an option explicitly, after having disabled it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93999fe3438fe0b785fe569963336719"></a><!-- doxytag: member="prf_utils::ProgArgs::set_rank" ref="a93999fe3438fe0b785fe569963336719" args="(int i)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a93999fe3438fe0b785fe569963336719">set_rank</a> (int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set rank, if you need to parse secondary settings. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0b416c33581998f5ebc6e52826c2808"></a><!-- doxytag: member="prf_utils::ProgArgs::settings_file_name" ref="ab0b416c33581998f5ebc6e52826c2808" args="(std::string flnm)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ab0b416c33581998f5ebc6e52826c2808">settings_file_name</a> (std::string flnm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a different settings file name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#af9daaab495dccc432300cfec312ded6c">settings_use_type</a> (int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Choose whether to use settings file.  <a href="#af9daaab495dccc432300cfec312ded6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a3ddc42051672807a901c5d1746ccc450">add_cmd_line_instructions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert command line arguments into InstructionStrings.  <a href="#a3ddc42051672807a901c5d1746ccc450"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace201e6fc1116b679244cd23fb14ccdc"></a><!-- doxytag: member="prf_utils::ProgArgs::get_settings" ref="ace201e6fc1116b679244cd23fb14ccdc" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ace201e6fc1116b679244cd23fb14ccdc">get_settings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get instructions from the settings files. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ab9414f1002c136c313108895a9d99"></a><!-- doxytag: member="prf_utils::ProgArgs::option_given" ref="af4ab9414f1002c136c313108895a9d99" args="(std::string optname)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#af4ab9414f1002c136c313108895a9d99">option_given</a> (std::string optname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is option optname given on the command line ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0f44bb8ee345662956e346f7549dba"></a><!-- doxytag: member="prf_utils::ProgArgs::option_available" ref="a2b0f44bb8ee345662956e346f7549dba" args="(std::string optname)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a2b0f44bb8ee345662956e346f7549dba">option_available</a> (std::string optname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is an option with this name currently available ? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a802bb4e294d7c89989880c02e297de16"></a><!-- doxytag: member="prf_utils::ProgArgs::option" ref="a802bb4e294d7c89989880c02e297de16" args="(std::string optname)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#a802bb4e294d7c89989880c02e297de16">option</a> (std::string optname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value passed for option "optname" on the command line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad12bd728d1a1edc66426c938b78f8dfa"></a><!-- doxytag: member="prf_utils::ProgArgs::option_arr" ref="ad12bd728d1a1edc66426c938b78f8dfa" args="(std::string, int)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ad12bd728d1a1edc66426c938b78f8dfa">option_arr</a> (std::string, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i'th value passed for option "optname" on the command line <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#aecd2ed887624b50fcaa28b4d4b2a5679">state_of_switch</a> (std::string swnm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is to query the state of the switch.  <a href="#aecd2ed887624b50fcaa28b4d4b2a5679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__utils_1_1ProgArgs.html#ac5793d6fd5441304395473ce96b81eed">switch_given</a> (std::string swnm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is to query if a switch was specified by the user.  <a href="#ac5793d6fd5441304395473ce96b81eed"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This utility class handles command line and settings file parameters for PROFASI programs. It converts all parameters passed through the command line, primary and secondary settings files, into a list of InstructionString objects.</p>
<p>An application program would need to define a <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a> object, tell it what options the application will accept, and how many arguments each of these options should expect. Then the application can ask the <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a> object to parse the command line and the settings files. Once this is done, the entire set of user requests can be obtained as a list of InstructionString objects using the function "get_options()". The application can then process the InstructionStrings in as appropriate.</p>
<p>On the command line, a string passed is an option if it starts with "-", unless it is a number. Options can be specified using long names (like "--output_file_name"), or with a short name ("-o"). <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a> does not discard any arguments found in the command line that it does not recognize as an option. All such arguments are stored as "spare_args", and can be retrieved as such by the application. If a program uses <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a> to parse its command line options, they can be passed in any order.</p>
<p>All options of a program can also be set using a settings file. The command line option "--settings-file" or "-st" can be used to change the name of the settings file. The default is "settings.cnf". This option, if present, is executed immediately. The other command line options are first collected and stored in a list. Settings file options are appended to that list.</p>
<p>The main program decides the priority of command line vs settings file. This class provides methods to parse command line and to read a settings file. Which ever comes last will have priority, in case a command appears twice. For some options, such as "add_chain" for programs like <a class="el" href="classBasicMCRun.html" title="Constant temperature Monte Carlo simulations.">BasicMCRun</a>, a second instance of the option does not replace the first, but simply adds one more chain.</p>
<p>The old ProFASi way of using <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a> was to access what value a user passed as a command line argument like in the following example. <br/>
 </p>
<div class="fragment"><pre class="fragment">
    ProgArgs opts;
    opts.option("output_file_name","o", 1);
    opts.analyze(argc,argv);

    std::string ofile="generic.output";
    if (opts.option_given("o")) ofile=opts.option("o");
    </pre></div><p>This will still work. But this will not retrieve instructions from the settings files. Avoid this. Do the following instead. <br/>
 </p>
<div class="fragment"><pre class="fragment">
    ProgArgs opts;
    opts.option("output_file_name","o", 1);
    opts.init_options(argc,argv);
    std::string ofile="generic.output";
    std::list&lt;InstructionString&gt; cmd=opts.get_options();
    for (std::list&lt;InstructionString&gt;::iterator it=cmd.begin();
        it!=cmd.end();++it) {
        if (it-&gt;head()=="output_file_name") ofile=it-&gt;tail().str();
    }
    </pre></div><p> Although the above seems longer than the old usage shown earlier, the new usage parses both the command line and settings file and deals with multiple instances of the same command in a sensible way. The developer needs to write only one command handling function taking care of the InstructionString, and not a separate one for command line and settings file. The end-user needs to remember only one set of options which work both with the settings file and the command line.</p>
<p>This class may some day be removed from PROFASI, and replaced with an alternative from a standard package (such as boost) providing the same functionality. For the present these few hundred lines of code help keep PROFASI self contained. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3ddc42051672807a901c5d1746ccc450"></a><!-- doxytag: member="prf_utils::ProgArgs::add_cmd_line_instructions" ref="a3ddc42051672807a901c5d1746ccc450" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::add_cmd_line_instructions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert whatever is passed on the command line into a lsit of InstructionStrings and add to the queue. This does not preserve the order in which the commands are passed. This is help with the flexibility that command line arguments can be passed in any order. Therefore, if you want commands to be executed in one particular order, use the settings file.</p>
<p>Also, by choosing when to call this function, the main program can set the priority of command line arguments relative to the settings file. Since (normally) one would execute the commands in the queue in sequence, the ones that come later will have the "last word". If this function is called before "get_settings()" the commands in the settings file will overwrite whatever was set with the command line. If called after <a class="el" href="classprf__utils_1_1ProgArgs.html#ace201e6fc1116b679244cd23fb14ccdc" title="Get instructions from the settings files.">get_settings()</a>, the command line arguments will have priority. Normally, you should not have to call this function directly at all. Just be happy with the sequence "opts.init_opts(argc,argv);
         cmdlist=opts.get_options();", unless you really can't do without fine grained control over the order of command line and settings file instructions. </p>

</div>
</div>
<a class="anchor" id="ab5e75ce45f27d6bd45f0d5bf1488eca2"></a><!-- doxytag: member="prf_utils::ProgArgs::analyze" ref="ab5e75ce45f27d6bd45f0d5bf1488eca2" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::analyze </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>argv</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function creates a list of options specified on the command line </p>

</div>
</div>
<a class="anchor" id="ad4fe85a2d39442ba8526fc9148dd6332"></a><!-- doxytag: member="prf_utils::ProgArgs::disable" ref="ad4fe85a2d39442ba8526fc9148dd6332" args="(std::string opnname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::disable </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>opnname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is useful if you want to inherit from a class which has a <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a> object, and want to edit the options supported. Adding new options is never a problem. But some of the options of the base class might not make sense for the derived class. They can then be "disabled". A disabled option can be enabled later. If such an option was meant to take arguments, it still will. But the values of the arguments will never be used. The function option_given always returns false for a disabled option. </p>

</div>
</div>
<a class="anchor" id="a04eeeb9f21830a1a77c12da5db4acc39"></a><!-- doxytag: member="prf_utils::ProgArgs::get_options" ref="a04eeeb9f21830a1a77c12da5db4acc39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;InstructionString&gt;&amp; prf_utils::ProgArgs::get_options </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This returns the combined list of InstructionStrings, possibly containing both command line arguments and settings file instructions. </p>

</div>
</div>
<a class="anchor" id="a75ff8d4192e9efe47280e8dd355cd1e2"></a><!-- doxytag: member="prf_utils::ProgArgs::init_options" ref="a75ff8d4192e9efe47280e8dd355cd1e2" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::init_options </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>argv</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function first acquires the command line options. If the special option "--settings_file" is given, that instruction is executed immediately, to change the name of the settings file. After that, instructions are acquired from the primary and secondary settings files. The command line instructions are appended at the end, so that there is one coherent list of instructions which can be executed to set up the application.</p>
<p><a class="anchor" id="secondary_settings"></a></p>
<p>Under the hood, some additional work is done to speed up processing of settings files. When a parallel application has to read the settings file, it is inefficient to have each and every process separately open and close the file. Now, only the rank 0 opens the primary settings file, and broadcasts the contents to the other ranks. In case there is a "secondary_settings on" instruction, each process proceeds to open its secondary settings file. There is also a new way to provide rank specific instructions in the primary settings file, so that the secondary settings is not really needed. For example, to set log_level to 100 on rank 0 and to 3 on every other rank, you would write this in the primary settings file:</p>
<div class="fragment"><pre class="fragment">
          log_level 3
          for_rank 0 log_level 3
          </pre></div><p> The rank specific commands are executed after the rank independent settings. There is also a "for_rank_range i j" version for the above command. The advantage of this method over the "secondary_settings" mechanism is that only one settings file is read by one process during start up. This will be relevant for people running ProFASi simulations with tens of thousands of MPI processes on large supercomputers. </p>

</div>
</div>
<a class="anchor" id="aacdad11b8e68dc732a94cd21fba74249"></a><!-- doxytag: member="prf_utils::ProgArgs::n_spare_args" ref="aacdad11b8e68dc732a94cd21fba74249" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int prf_utils::ProgArgs::n_spare_args </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Are there any arguments passed on the command line that were not recognized as any of the known options or any values processed along with those options ? Such command line arguments are stored separately as "spare arguments". This function returns the number of such arguments. </p>

</div>
</div>
<a class="anchor" id="ae9a8dec1c3df8de1f6f7a30d4af4fd71"></a><!-- doxytag: member="prf_utils::ProgArgs::new_switch" ref="ae9a8dec1c3df8de1f6f7a30d4af4fd71" args="(std::string longname, std::string shortname, bool defstate=true, std::string helptext=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::new_switch </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>longname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>shortname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>defstate</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>helptext</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A switch is like an option, but it does not take any arguments. It may be turned on or off on the command line or the settings file for some effect on the program. For example, imagine that a switch called "verbose", or "v" is created with this function. In the program, one can now use the command line option "-v", to have the intended effect of "verbose". If the program is so written that the default mode is verbose, one would be able to turn this switch off by using the option "--no-verbose". The role of the function parameter "defstate" is to specify if the switch is on or off by default. This default value is used, when the user does not explicitly pass it on the command line. </p>

</div>
</div>
<a class="anchor" id="a9317a4b392037c0813ba0c1b06c682d9"></a><!-- doxytag: member="prf_utils::ProgArgs::option" ref="a9317a4b392037c0813ba0c1b06c682d9" args="(std::string longname, std::string shortname, int nargus, std::string helptext=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::option </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>longname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>shortname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nargus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>helptext</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When a new option is added for handling, it has to be identified with a long and a short name. The number of arguments to be expected after this option (for command line input) must be specified, and optionally a small info text clarifying the option when needed. For instance, an option might expect only integers between 0 and 5. The help text could then be "{0--5}".</p>
<p>A special case arises when we extend the command line parser to process what used to be handled exclusively in a settings file. Settings file commands such as add_chain or new_obs take an indefinite number of arguments:</p>
<div class="fragment"><pre class="fragment">
        add_chain 1 &lt; ACE * NYSDFRIKLK * NH2 &gt;
        new_obs ProteinRMSD rmsd using +BB ; struc1 abc.pdb:5:A,2,11 ; struc2 $::A
        new_obs Rg rg
        </pre></div><p>To set up such commands for <a class="el" href="classprf__utils_1_1ProgArgs.html" title="A utility to help manage program parameters.">ProgArgs</a>, pretend that they are commands which take one or two string arguments. </p>
<div class="fragment"><pre class="fragment">
        ProgArgs opts;
        opts.option("add_chain","add_chain", 2,"(number of chains and sequence)");
        opts.option("new_obs","new_obs", 1, "(add a new observable)");
        opts.init_options(argc,argv);
        </pre></div><p>This way, add chain will expect two arguments and new_obs only 1. They can be used as follows: </p>
<div class="fragment"><pre class="fragment">
        $ some_program --add_chain 1 "&lt; ACE * NZSDFRIKLK * NH2 &gt;" --new_obs "Rg rg"
        </pre></div><p>Remember that every command line option can now be written in the settings file, without the "--" and the quotation marks in the settings file. </p>

</div>
</div>
<a class="anchor" id="af9daaab495dccc432300cfec312ded6c"></a><!-- doxytag: member="prf_utils::ProgArgs::settings_use_type" ref="af9daaab495dccc432300cfec312ded6c" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::settings_use_type </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>One can choose whether the application uses the settings file parsing features provided here. Calling this function with argument 0 turns off settings file parsing altogether. If it is 1, the program will always try to find a settings file, and use it. A value 2 here means the use of a settings file is conditional. By default no settings file will be looked for. But if the user explicitly provides a settings file with the "-st" option and that file exists, it will be parsed. </p>

</div>
</div>
<a class="anchor" id="aecd2ed887624b50fcaa28b4d4b2a5679"></a><!-- doxytag: member="prf_utils::ProgArgs::state_of_switch" ref="aecd2ed887624b50fcaa28b4d4b2a5679" args="(std::string swnm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prf_utils::ProgArgs::state_of_switch </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>swnm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the user specified the switch through the command line or the settings file, the value specified will be returned. If the user didn't specify anything, the default value for the respective switch will be returned. </p>

</div>
</div>
<a class="anchor" id="ac5793d6fd5441304395473ce96b81eed"></a><!-- doxytag: member="prf_utils::ProgArgs::switch_given" ref="ac5793d6fd5441304395473ce96b81eed" args="(std::string swnm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prf_utils::ProgArgs::switch_given </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>swnm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This just returns whether the user specified a value. Not what value. </p>

</div>
</div>
<a class="anchor" id="af446793145edb05da55a002e1378d713"></a><!-- doxytag: member="prf_utils::ProgArgs::write_available" ref="af446793145edb05da55a002e1378d713" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf_utils::ProgArgs::write_available </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lists them along with the expected number of arguments and the corresponding short help texts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/Aux/ProgUtils.hh</li>
<li>model/Aux/ProgUtils.cc</li>
</ul>
</div>
<center>
<hr>
<small>
<strong>PROFASI: Protein Folding and Aggregation Simulator, Version 1.5 
</strong><br />
&copy; (2005-2009) <a href="http://www.thep.lu.se/~anders">Anders Irb&auml;ck</a>
and <a href="http://www.thep.lu.se/~sandipan">Sandipan Mohanty</a><br />
Documentation generated on 19 Jun 2014 using Doxygen version 1.6.1
</small>
</center>

</body>
</html> 
