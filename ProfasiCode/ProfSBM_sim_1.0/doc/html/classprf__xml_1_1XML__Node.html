<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PROFASI: prf_xml::XML_Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>prf_xml</b>::<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a>
  </div>
</div>
<div class="contents">
<h1>prf_xml::XML_Node Class Reference<br/>
<small>
[<a class="el" href="group__profasi__XML.html">ProFASi XML module</a>]</small>
</h1><!-- doxytag: class="prf_xml::XML_Node" -->
<p>A class to represent an XML node.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;prf_xml.hh&gt;</code></p>

<p><a href="classprf__xml_1_1XML__Node-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a448e007af54e2cdb0c085c9c10938e18"></a><!-- doxytag: member="prf_xml::XML_Node::XML_Node" ref="a448e007af54e2cdb0c085c9c10938e18" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a448e007af54e2cdb0c085c9c10938e18">XML_Node</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6e626a443a77333018d1f49745d4a97"></a><!-- doxytag: member="prf_xml::XML_Node::XML_Node" ref="aa6e626a443a77333018d1f49745d4a97" args="(const XML_Node &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#aa6e626a443a77333018d1f49745d4a97">XML_Node</a> (const <a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a4456bde0f439d98ffa5d05003290536d">make_clone_of</a> (const <a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a real detached copy with the same information.  <a href="#a4456bde0f439d98ffa5d05003290536d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a16a5f480f466e7cbc5da8896acd604d3">XML_Node</a> (std::list&lt; <a class="el" href="classprf__xml_1_1Chunk.html">prf_xml::Chunk</a> &gt;::iterator bg, std::list&lt; <a class="el" href="classprf__xml_1_1Chunk.html">prf_xml::Chunk</a> &gt;::iterator nd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from a range of "Chunks".  <a href="#a16a5f480f466e7cbc5da8896acd604d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bfc82a03b06a36790b41e85b837e55a"></a><!-- doxytag: member="prf_xml::XML_Node::operator=" ref="a0bfc82a03b06a36790b41e85b837e55a" args="(const XML_Node &amp;)" -->
<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a0bfc82a03b06a36790b41e85b837e55a">operator=</a> (const <a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#ad5bccbe9adaae231dd59b2a14d3b733e">XML_Node</a> (std::string nm, std::string vl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a node with a tag name and some data.  <a href="#ad5bccbe9adaae231dd59b2a14d3b733e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1972f1af9c7206f209732bd0587ec6df"></a><!-- doxytag: member="prf_xml::XML_Node::set_name" ref="a1972f1af9c7206f209732bd0587ec6df" args="(std::string nm)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a1972f1af9c7206f209732bd0587ec6df">set_name</a> (std::string nm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the tag name (no syntax check!!). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e19ffe21284a11183e030837803a85f"></a><!-- doxytag: member="prf_xml::XML_Node::set_value" ref="a0e19ffe21284a11183e030837803a85f" args="(std::string vl)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a0e19ffe21284a11183e030837803a85f">set_value</a> (std::string vl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the text data (no syntax check!!). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d3401bdf1bde7621300dc005faf4ad0"></a><!-- doxytag: member="prf_xml::XML_Node::name" ref="a6d3401bdf1bde7621300dc005faf4ad0" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a6d3401bdf1bde7621300dc005faf4ad0">name</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the name of a node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a1c5b91e2f0ad31edf093b8c24b69cef8">value</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the text data stored in the node.  <a href="#a1c5b91e2f0ad31edf093b8c24b69cef8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#ab830848dfbf9091dfaf0d5decef0e727">is_leaf_node</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the node is a leaf node.  <a href="#ab830848dfbf9091dfaf0d5decef0e727"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#ad32dc8a7d15655fab4844778af1efbe0">attribute</a> (std::string a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a particular attribute.  <a href="#ad32dc8a7d15655fab4844778af1efbe0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7843d3fe04f73da2ad3abacc022b9b6"></a><!-- doxytag: member="prf_xml::XML_Node::n_attributes" ref="aa7843d3fe04f73da2ad3abacc022b9b6" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#aa7843d3fe04f73da2ad3abacc022b9b6">n_attributes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of attributes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e7c7efe5e18e6fb6f6c27773c8cc5cf"></a><!-- doxytag: member="prf_xml::XML_Node::attributes" ref="a6e7c7efe5e18e6fb6f6c27773c8cc5cf" args="()" -->
std::map&lt; std::string, <br class="typebreak"/>
std::string &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a6e7c7efe5e18e6fb6f6c27773c8cc5cf">attributes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to the attribute map. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af25c0f12361f0b91f5026f6ff6deb71b"></a><!-- doxytag: member="prf_xml::XML_Node::n_children" ref="af25c0f12361f0b91f5026f6ff6deb71b" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#af25c0f12361f0b91f5026f6ff6deb71b">n_children</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f652495b0e56efaa4c7cd5a4e47e9cb"></a><!-- doxytag: member="prf_xml::XML_Node::child" ref="a1f652495b0e56efaa4c7cd5a4e47e9cb" args="(size_t i)" -->
<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a1f652495b0e56efaa4c7cd5a4e47e9cb">child</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i'th child node <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3781ef1a7e7d61f5ababd6cb284a4c20"></a><!-- doxytag: member="prf_xml::XML_Node::child" ref="a3781ef1a7e7d61f5ababd6cb284a4c20" args="(std::string nm)" -->
<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a3781ef1a7e7d61f5ababd6cb284a4c20">child</a> (std::string nm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the first child node with a given name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6070210dc249087f64dda2e92b0294c9"></a><!-- doxytag: member="prf_xml::XML_Node::children" ref="a6070210dc249087f64dda2e92b0294c9" args="()" -->
std::deque&lt; <a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a6070210dc249087f64dda2e92b0294c9">children</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to the deque of children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a380a565a6b139f0500644e5bbba44"></a><!-- doxytag: member="prf_xml::XML_Node::add_child_node" ref="aa2a380a565a6b139f0500644e5bbba44" args="(XML_Node *ch)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#aa2a380a565a6b139f0500644e5bbba44">add_child_node</a> (<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *ch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a993646d6e7d034c1767016dd468fd1a6"></a><!-- doxytag: member="prf_xml::XML_Node::remove_child_node" ref="a993646d6e7d034c1767016dd468fd1a6" args="(std::string nm)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a993646d6e7d034c1767016dd468fd1a6">remove_child_node</a> (std::string nm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a node from the deque of child nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01505920f4dbba32043d07945e76e217"></a><!-- doxytag: member="prf_xml::XML_Node::remove_child_node" ref="a01505920f4dbba32043d07945e76e217" args="(XML_Node *nd)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a01505920f4dbba32043d07945e76e217">remove_child_node</a> (<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *nd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a18d62bf19b58bfee60e9bdcbfcf93302">disown_child_node</a> (<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *nd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disown a child node.  <a href="#a18d62bf19b58bfee60e9bdcbfcf93302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4eb944ff01c37850fbb9affbf57c2ea"></a><!-- doxytag: member="prf_xml::XML_Node::add_child_node" ref="ab4eb944ff01c37850fbb9affbf57c2ea" args="(std::string nm, std::string vl)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#ab4eb944ff01c37850fbb9affbf57c2ea">add_child_node</a> (std::string nm, std::string vl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new child node with given name and value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af52d4f0efc7fd1ecc692a9920e77d5aa"></a><!-- doxytag: member="prf_xml::XML_Node::clear_child_nodes" ref="af52d4f0efc7fd1ecc692a9920e77d5aa" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#af52d4f0efc7fd1ecc692a9920e77d5aa">clear_child_nodes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all child nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6092e7ea321e2c64e329f0748155fdf6"></a><!-- doxytag: member="prf_xml::XML_Node::state" ref="a6092e7ea321e2c64e329f0748155fdf6" args="() const " -->
state_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a6092e7ea321e2c64e329f0748155fdf6">state</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not the XML node is in an error free state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d30813a84acc046ffbad0533321feb8"></a><!-- doxytag: member="prf_xml::XML_Node::encloses" ref="a0d30813a84acc046ffbad0533321feb8" args="(XML_Node &amp;gn)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a0d30813a84acc046ffbad0533321feb8">encloses</a> (<a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> &amp;gn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether it encloses another XML node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee19f30681e747fb94c6bf4f42cca806"></a><!-- doxytag: member="prf_xml::XML_Node::make_string" ref="aee19f30681e747fb94c6bf4f42cca806" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#aee19f30681e747fb94c6bf4f42cca806">make_string</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a string out of the information in the node and its children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a1fa8022748c9e2a3d2ad30b3fa549266">write</a> (prf::Output &amp;op, int indent_level=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the XML node and its children for visualisation.  <a href="#a1fa8022748c9e2a3d2ad30b3fa549266"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf__xml_1_1XML__Node.html#a2158a82b86c1cbca3be94b05ad49b084">interpret_formatted_data</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpret formatted data as a series of child nodes.  <a href="#a2158a82b86c1cbca3be94b05ad49b084"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An XML node represents the information enclosed within the scope of an XML tag. It has a name, some data, and a deque of pointers to other nodes regarded as its children. These child nodes are the XML tags contained within the scope of the original tag. For example, <br/>
 <br/>
</p>
<div class="fragment"><pre class="fragment">
    &lt;protein&gt;
    &lt;sequence&gt;
    ACE * KLVFFAE * NH2
    &lt;/sequence&gt;
    &lt;group index="0" type="ACE"&gt;
    &lt;dof&gt;
    4.0092316407542254
    &lt;/dof&gt;
    &lt;/group&gt;
    &lt;group index="1" type="LYS"&gt;
    &lt;dof&gt;
    -0.3131207777043232   -1.3363358975000719   -3.1415926535897931
    4.5758682133671185   2.8279753720956338   1.1606113829381837
    3.1121544489086883   1.9936435953881690
    &lt;/dof&gt;
    &lt;/group&gt;
    &lt;/protein&gt;
    </pre></div><p>represents a short tree with information about the beginning part of a peptide. The root node in this case has a name "protein". It has a few child nodes (i) A child node called "sequence", which contains the sequence of the peptide as its data and no children of its own. (ii) 2 child nodes with name "group". In this instance, these two are distinguishable by their attributes "index" and "type". Each group contains a child node of its own, called "dof", with the double precision values of, presumably, the degrees of freedom in that residue. Notice that the name of a node appears in the opening and closing tags that define the scope of the node. Tags for the child nodes are enclosed within the scope of the parent node. The opening tag can optionally contain one or more attributes of arbitray names. Attribute values must be enclosed in quotes. There are no commas between different attributes, so that they are only distinguished by identifying name="value" patterns.</p>
<p>This class is an interface to the attributes and information contained in an XML node and its children. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a16a5f480f466e7cbc5da8896acd604d3"></a><!-- doxytag: member="prf_xml::XML_Node::XML_Node" ref="a16a5f480f466e7cbc5da8896acd604d3" args="(std::list&lt; prf_xml::Chunk &gt;::iterator bg, std::list&lt; prf_xml::Chunk &gt;::iterator nd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XML_Node::XML_Node </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="classprf__xml_1_1Chunk.html">prf_xml::Chunk</a> &gt;::iterator&nbsp;</td>
          <td class="paramname"> <em>bg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="classprf__xml_1_1Chunk.html">prf_xml::Chunk</a> &gt;::iterator&nbsp;</td>
          <td class="paramname"> <em>nd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normally this should not concern you unless you intend to want to improve the construction of the XML tree in some way. It takes a range of <a class="el" href="classprf__xml_1_1Chunk.html" title="A &quot;chunk&quot; of data in an XML file.">Chunk</a> objects and tries to generate a node out of it. The range of chunks is assumed to start with a begin tag, end with an end tag and contain only data within these tags, i.e., no enclosed child nodes. Read the documentation of the <a class="el" href="classprf__xml_1_1Chunk.html" title="A &quot;chunk&quot; of data in an XML file.">Chunk</a> and <a class="el" href="classprf__xml_1_1XML__Mini.html" title="A small class to do the book keeping for XML parsing.">XML_Mini</a> classes for further details of how and why it is used. If you only want to use the XML module, you can safely ignore this function.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classprf__xml_1_1Chunk.html" title="A &quot;chunk&quot; of data in an XML file.">Chunk</a> </dd>
<dd>
<a class="el" href="classprf__xml_1_1XML__Mini.html" title="A small class to do the book keeping for XML parsing.">XML_Mini</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5bccbe9adaae231dd59b2a14d3b733e"></a><!-- doxytag: member="prf_xml::XML_Node::XML_Node" ref="ad5bccbe9adaae231dd59b2a14d3b733e" args="(std::string nm, std::string vl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XML_Node::XML_Node </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nm</em>&nbsp;</td><td>Name or tag name for the XML node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vl</em>&nbsp;</td><td>Text data for the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad32dc8a7d15655fab4844778af1efbe0"></a><!-- doxytag: member="prf_xml::XML_Node::attribute" ref="ad32dc8a7d15655fab4844778af1efbe0" args="(std::string a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string prf_xml::XML_Node::attribute </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Empty string if the desired attribute does not exist </p>

</div>
</div>
<a class="anchor" id="a18d62bf19b58bfee60e9bdcbfcf93302"></a><!-- doxytag: member="prf_xml::XML_Node::disown_child_node" ref="a18d62bf19b58bfee60e9bdcbfcf93302" args="(XML_Node *nd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_Node::disown_child_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *&nbsp;</td>
          <td class="paramname"> <em>nd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If nd is a child node, it will be removed from the child list but its contents will not be touched. So, the responsibility of deleting that node will no longer be with the original parent node. </p>

</div>
</div>
<a class="anchor" id="a2158a82b86c1cbca3be94b05ad49b084"></a><!-- doxytag: member="prf_xml::XML_Node::interpret_formatted_data" ref="a2158a82b86c1cbca3be94b05ad49b084" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_Node::interpret_formatted_data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function interprets formatted data, and hence implements the XML template handling for ProFASi. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>xml_templates </dd></dl>

</div>
</div>
<a class="anchor" id="ab830848dfbf9091dfaf0d5decef0e727"></a><!-- doxytag: member="prf_xml::XML_Node::is_leaf_node" ref="ab830848dfbf9091dfaf0d5decef0e727" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prf_xml::XML_Node::is_leaf_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true, if the node has no children, no attributes, and the value text does not contain more than 80 characters. </p>

</div>
</div>
<a class="anchor" id="a4456bde0f439d98ffa5d05003290536d"></a><!-- doxytag: member="prf_xml::XML_Node::make_clone_of" ref="a4456bde0f439d98ffa5d05003290536d" args="(const XML_Node *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML_Node::make_clone_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprf__xml_1_1XML__Node.html">XML_Node</a> *&nbsp;</td>
          <td class="paramname"> <em>tg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The copy constructor copies all elements, including the pointers. The child nodes are pointers to other XML_Nodes. So, if we construct a copy using the copy constructor, we end up with two XML_Nodes which have elements pointing to the same memory address. This could lead to problems when the nodes are deleted. When we want a duplicate, one should use this function instead. </p>

</div>
</div>
<a class="anchor" id="a1c5b91e2f0ad31edf093b8c24b69cef8"></a><!-- doxytag: member="prf_xml::XML_Node::value" ref="a1c5b91e2f0ad31edf093b8c24b69cef8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string prf_xml::XML_Node::value </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If data is stored in the file non-contiguously with child XML tags interspersed between text data blocks, the data belonging to the node (and not to the child nodes) will be collected in one place. This function then returns all the data belonging to the node. </p>

</div>
</div>
<a class="anchor" id="a1fa8022748c9e2a3d2ad30b3fa549266"></a><!-- doxytag: member="prf_xml::XML_Node::write" ref="a1fa8022748c9e2a3d2ad30b3fa549266" args="(prf::Output &amp;op, int indent_level=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XML_Node::write </td>
          <td>(</td>
          <td class="paramtype">prf::Output &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>indent_level</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is only to see that the XML parsing has worked. It writes the node tag, defines its scope like the scope of a C function, shows the attributes like arguments to the function, uses indentation to represent the hierarchy. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/Aux/prf_xml.hh</li>
<li>model/Aux/prf_xml.cc</li>
</ul>
</div>
<center>
<hr>
<small>
<strong>PROFASI: Protein Folding and Aggregation Simulator, Version 1.5 
</strong><br />
&copy; (2005-2009) <a href="http://www.thep.lu.se/~anders">Anders Irb&auml;ck</a>
and <a href="http://www.thep.lu.se/~sandipan">Sandipan Mohanty</a><br />
Documentation generated on 19 Jun 2014 using Doxygen version 1.6.1
</small>
</center>

</body>
</html> 
