Another elementary application, illustrating the self adjusting histograms of 
PROFASI. The program reads data from the standard input, and upon EOF, saves
a histogram of the data. 

There are command line arguments for setting the initial range and number of
bins, as well as output file name. If the data entered does not fit in the 
range, the histogram may auto-adjust to cover the data. We say "may", and not
"will" because the histogram can refuse to extend the bins to accommodate some
points. The policy used to decide whether to create more bins or not is this:
Bins are created because we want to remember less data. If one data point is
so far from the rest that we would need 100 extra bins to accommodate it, it
is clearly more convenient to remember that data point instead. The histogram
changes its range if and only if it is advantageous compared to remembering 
the out-of-range points. The out-of-range points are never forgotten. When
the histogram is saved, the out-of-range points are saved in a separate
obviously named file. 

To compile, type "make", or "make CC=your_compiler". To get a list of supported
command line options, type the name of the executable on the command line.

If you just run the program with its command line arguments, it seems to be
doing nothing. It is actually waiting for user input. Just type in numbers to
fill the histogram. When done, press Control-D. It then saves the histogram file. 

This trivial program is potentially quite useful. It is often required to quickly
generate a histogram of data generated by one application. If you can print
the data to the standard output from another application, you can pipe that
output to this program to generate a histogram.

We illustrate this using the example program ../random_numbers/ran_example.ex.

$ ../random_numbers/ran_example.ex -m 0 -d 1 -n 1000000 | his_example.ex -nb 100 \
	-r -15 -10 -na 1000 -o his.out

The part before the "pipe" character '|' is what you need to type to execute the
ran_example.ex program. The output of that program is one million Gaussian 
random numbers with mean 0 and standard deviation 1. That output becomes the
standard input of his_example.ex because of the pipe. So, the result is as if
you had typed those one million values by hand to the his_example.ex program. 
Notice that in the "range" option "-r", we gave some stupid values. A Gaussian
with 0 mean and 1 standard deviation is very unlikely to produce too many data
points there. But the histogram will adjust the range so that it gets the data
anyway. The range re-adjustments are done at a frequency controlled by the 
command line option "-na". In this instance, the histogram does the adjusting
every 1000 data entries. Plot the generated histogram his.out, and compare
it with a plot of f(x)=(1.0/sqrt(2*pi*sigma*sigma))*exp(-x*x/(2*sigma*sigma))
They should agree.

Now, try changing the range options and the number of bins. In each case, 
the result should look broadly similar. Changing the number of bins of the range
changes the bin size. But the default normalization of the histograms is
such that Sum{ value(i)*binsize/Ndata, i=0..Nbins}=1. So, if the frequency
of data points in bin i is frequency(i), value(i)=frequency(i)/(Ndata*binsize).

If you want, you can normalize the histograms in a different way. The "-ntype"
option can be used to normalize so that Sum{value(i)/Ndata, i=0..Nbins}=1. This
needs the ntype to be 1. ntype of 0 means no normalization at all. The default
is ntype 2. 
 
