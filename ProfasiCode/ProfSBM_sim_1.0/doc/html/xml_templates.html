<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PROFASI: XML templates: Auto-generate complex XML nodes from tabular data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="toc.html">Table of contents</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="xml_templates">XML templates: Auto-generate complex XML nodes from tabular data </a></h1><p>Often XML data consists of a large sequence of nodes of identical format with different entries. Although it is more convenient to analyze the data as a sequence of XML nodes, writing out each node in the standard XML format is unnecessarily verbose. Storing such data in the table form in a file with comma or white space separated columns is space efficient and convenient from the point of view of scripting. But this approach makes us commit to a certain data layout and not very accommodative of unexpected new directions. ProFASi's XML module provides a template handling mechanism to auto-generate XML nodes from tabular data.</p>
<p>An <a class="el" href="classprf__xml_1_1XML__Node.html" title="A class to represent an XML node.">XML_Node</a> with a child node of name "formatted_data" can substitute a series of child nodes based on the contents of a <em>formatted_data</em> child. Each <em>formatted_data</em> node must have children of names "format" and "data" (See example below). Each line of input inside the <em>data</em> field will be interpreted as a record, represented by XML nodes described by the <em>format</em>. The format field can address different fields in the data line in <em>awk</em> style, <em>$1</em> <em>$2</em> etc. Example:</p>
<div class="fragment"><pre class="fragment">
  &lt;some_node&gt;
  &lt;arbitrary_property_1&gt;
    This is some generic property.
  &lt;/arbitrary_property_1&gt;
  &lt;formatted_data&gt;
    &lt;format name="snapshot"&gt;
      &lt;MC_time&gt;$1&lt;/MC_time&gt;
      &lt;temperature&gt;$2&lt;/temperature&gt;
      &lt;energy&gt;$3&lt;/energy&gt;
      &lt;helix&gt;$4&lt;/helix&gt;
      &lt;strand&gt;$5&lt;/strand&gt;
    &lt;/format&gt;
    &lt;data&gt;
      999  0  33.391879  0.071429  0.357143
      1999  3  67.611951  0.000000  0.071429
      2999  2  53.211118  0.000000  0.000000
    &lt;/data&gt;
  &lt;/formatted_data&gt;
  &lt;/some_node&gt;
  </pre></div><p>If function <a class="el" href="classprf__xml_1_1XML__Node.html#a2158a82b86c1cbca3be94b05ad49b084" title="Interpret formatted data as a series of child nodes.">prf_xml::XML_Node::interpret_formatted_data()</a> is called on <a class="el" href="classprf__xml_1_1XML__Node.html" title="A class to represent an XML node.">XML_Node</a>  some_node, the content of the node  some_node will change to the following: </p>
<div class="fragment"><pre class="fragment">
  &lt;some_node&gt;
  &lt;arbitrary_property_1&gt;
    This is some generic property.
  &lt;/arbitrary_property_1&gt;
  &lt;snapshot&gt;
      &lt;MC_time&gt;999&lt;/MC_time&gt;
      &lt;temperature&gt;0&lt;/temperature&gt;
      &lt;energy&gt;33.391879&lt;/energy&gt;
      &lt;helix&gt;0.071429&lt;/helix&gt;
      &lt;strand&gt;0.357143&lt;/strand&gt;
  &lt;/snapshot&gt;
  &lt;snapshot&gt;
      &lt;MC_time&gt;1999&lt;/MC_time&gt;
      &lt;temperature&gt;3&lt;/temperature&gt;
      &lt;energy&gt;67.611951&lt;/energy&gt;
      &lt;helix&gt;0.000000&lt;/helix&gt;
      &lt;strand&gt;0.071429&lt;/strand&gt;
  &lt;/snapshot&gt;
  &lt;snapshot&gt;
      &lt;MC_time&gt;2999&lt;/MC_time&gt;
      &lt;temperature&gt;2&lt;/temperature&gt;
      &lt;energy&gt;53.211118&lt;/energy&gt;
      &lt;helix&gt;0.000000&lt;/helix&gt;
      &lt;strand&gt;0.000000&lt;/strand&gt;
  &lt;/snapshot&gt;
  &lt;/some_node&gt;
  </pre></div><p> The advantage of being able to do this is that an application can process the data by accessing XML nodes with given names. The correspondence between those nodes and columns of data in a tabular file is left completely open. So, an external application can generate data in arbitrary format. So long as there is a format specifier block added and the data copied into a data field, it can be interpreted by the processing program without any change.</p>
<p>Tip: In the formatted data node, there is an alternative to the data node, called  import_data. The content of  import_data node should be a file name. During interpretation, the block </p>
<div class="fragment"><pre class="fragment">
  &lt;import_data&gt;tabular_file.dat&lt;/import_data&gt;
  </pre></div><p> is interpreted as if it was </p>
<div class="fragment"><pre class="fragment">
  &lt;data&gt;
  contents of the file tabular_file.dat
  &lt;/data&gt;
  </pre></div><p> This way, you can construct many small XML files of arbitrarily different node structure using the information in the same tabular data file.</p>
<p>The interpretation of formatted data happens only if one calls the function interpret_formatted_data() for the specific XML node. This happens by default for all ProFASi simulation programs which read XML configurations. But this happens because they explicitly call the interpret_... function after retrieving an XML node from the XML file. If you want to use this feature in a new program you write, make sure you do something like this: </p>
<div class="fragment"><pre class="fragment">
  prf_xml::XML_Node * root=prf_xml::get_xml_tree("some_file.xml");
  root-&gt;interpret_formatted_data();
  </pre></div> </div>
<center>
<hr>
<small>
<strong>PROFASI: Protein Folding and Aggregation Simulator, Version 1.5 
</strong><br />
&copy; (2005-2009) <a href="http://www.thep.lu.se/~anders">Anders Irb&auml;ck</a>
and <a href="http://www.thep.lu.se/~sandipan">Sandipan Mohanty</a><br />
Documentation generated on 19 Jun 2014 using Doxygen version 1.6.1
</small>
</center>

</body>
</html> 
