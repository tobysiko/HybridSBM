<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PROFASI: prf::Energy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceprf.html">prf</a>::<a class="el" href="classprf_1_1Energy.html">Energy</a>
  </div>
</div>
<div class="contents">
<h1>prf::Energy Class Reference<br/>
<small>
[<a class="el" href="group__profasi__energies.html">Energy Classes</a>]</small>
</h1><!-- doxytag: class="prf::Energy" --><!-- doxytag: inherits="prf::Observable" -->
<p><a class="el" href="classprf_1_1Energy.html" title="Energy base class.">Energy</a> base class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Energy.hh&gt;</code></p>

<p>Inherits <a class="el" href="classprf_1_1Observable.html">prf::Observable</a>.</p>

<p>Inherited by <a class="el" href="classprf_1_1Bias.html">prf::Bias</a>, <a class="el" href="classprf_1_1ChargedSCInteraction.html">prf::ChargedSCInteraction</a>, <a class="el" href="classprf_1_1DihedralRestraints.html">prf::DihedralRestraints</a>, <a class="el" href="classprf_1_1DistanceRestraints.html">prf::DistanceRestraints</a>, <a class="el" href="classprf_1_1ExVol.html">prf::ExVol</a>, <a class="el" href="classprf_1_1HBMM.html">prf::HBMM</a>, <a class="el" href="classprf_1_1HBMS.html">prf::HBMS</a>, <a class="el" href="classprf_1_1Hydrophobicity.html">prf::Hydrophobicity</a>, <a class="el" href="classprf_1_1LocExVol.html">prf::LocExVol</a>, <a class="el" href="classprf_1_1ObsEnergy.html">prf::ObsEnergy</a>, and <a class="el" href="classprf_1_1TorsionTerm.html">prf::TorsionTerm</a>.</p>

<p><a href="classprf_1_1Energy-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d184db2b37efdba792feebd31511f1e"></a><!-- doxytag: member="prf::Energy::Connect" ref="a2d184db2b37efdba792feebd31511f1e" args="(Population *pl)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a2d184db2b37efdba792feebd31511f1e">Connect</a> (<a class="el" href="classprf_1_1Population.html">Population</a> *pl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the energy term with one population. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a4d10b1991e8b78c2b167fbf18205b0a5">set_pars</a> (std::string pars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set some adjustible parameters.  <a href="#a4d10b1991e8b78c2b167fbf18205b0a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99789800a111ffcdd882fdfead142c7e"></a><!-- doxytag: member="prf::Energy::refresh" ref="a99789800a111ffcdd882fdfead142c7e" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a99789800a111ffcdd882fdfead142c7e">refresh</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overrides the virtual member from the <a class="el" href="classprf_1_1Observable.html" title="An observable is in principle anything that is named and has a value.">Observable</a> class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b3f7770a7574e0ceb4ed8f75f79a8f"></a><!-- doxytag: member="prf::Energy::value" ref="a16b3f7770a7574e0ceb4ed8f75f79a8f" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a16b3f7770a7574e0ceb4ed8f75f79a8f">value</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return result from last calculation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a290fb59fb7786b6731088f1593c61378"></a><!-- doxytag: member="prf::Energy::deltaE" ref="a290fb59fb7786b6731088f1593c61378" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a290fb59fb7786b6731088f1593c61378">deltaE</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return result from the last energy change calculation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#ab9d1ee6ac6344ddd86ac15b8a3b69b19">evaluate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8417ea24a4c2cd7f2590475f3c177ef"></a><!-- doxytag: member="prf::Energy::deltaE" ref="aa8417ea24a4c2cd7f2590475f3c177ef" args="(Update *)" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#aa8417ea24a4c2cd7f2590475f3c177ef">deltaE</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">do a new delta calculation optimized for the given kind of update <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a1036bde92a6b425afb03edc6243791ad">delta</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quick estimate of the change in an <a class="el" href="classprf_1_1Observable.html" title="An observable is in principle anything that is named and has a value.">Observable</a> due to an update.  <a href="#a1036bde92a6b425afb03edc6243791ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a2858fcc4d2cfa0823fada58915b8797a">deltaEwithlimit</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *updt, double maxde)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate energy change for an update, but with a stop condition.  <a href="#a2858fcc4d2cfa0823fada58915b8797a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#ac02fa5cca1cc393bf8357f7091e32e46">Accept</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a proposed update.  <a href="#ac02fa5cca1cc393bf8357f7091e32e46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29ed6b0c7118ae11d8353e452b19704"></a><!-- doxytag: member="prf::Energy::Revert" ref="ac29ed6b0c7118ae11d8353e452b19704" args="(Update *)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#ac29ed6b0c7118ae11d8353e452b19704">Revert</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reject a proposed update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#acb8ea3b9fba3fd8c82f2efcc6695c38f">rangeEstimate</a> (double &amp;x1, double &amp;x2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate a range in which values of this observable are expected.  <a href="#acb8ea3b9fba3fd8c82f2efcc6695c38f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1Energy.html#a5048a7d6604c288cb8ef62f94e6030c8">init_obs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All observables must implement one initialize routine.  <a href="#a5048a7d6604c288cb8ef62f94e6030c8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classprf_1_1Energy.html" title="Energy base class.">Energy</a> base class declares an interface for different energy terms which can be used, for instance, to decide whether a certain update is to be accepted. All energy terms in ProFASi are implemented as derived classes of this class. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac02fa5cca1cc393bf8357f7091e32e46"></a><!-- doxytag: member="prf::Energy::Accept" ref="ac02fa5cca1cc393bf8357f7091e32e46" args="(Update *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::Energy::Accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf_1_1Update.html">Update</a> *&nbsp;</td>
          <td class="paramname"> <em>updt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PROFASI uses many local contribution matrices and backup variables to quickly evaluate the change caused to any energy term by a given update. Those backup variables and the contribution matrices need to be kept in sync with the current system configuration. So, each energy class has an accept and a reject method, which are called when an update is accepted or rejected. What is done inside these functions depends on the energy term and optimization trick used therein. </p>

<p>Reimplemented in <a class="el" href="classprf_1_1Bias.html#ae8d8a223c03c6a3f444a6c81d13e16ac">prf::Bias</a>, <a class="el" href="classprf_1_1ChargedSCInteraction.html#ae89d8ed91ea25105802208434c1539fd">prf::ChargedSCInteraction</a>, <a class="el" href="classprf_1_1ExVol.html#a4fd027c1ac9303dedcfad13f2fb51975">prf::ExVol</a>, <a class="el" href="classprf_1_1HBMM.html#a922154c184671b948ef52a0fdacd2cea">prf::HBMM</a>, <a class="el" href="classprf_1_1HBMS.html#a635015c929b79aa670f3b8ec5d2fb1fc">prf::HBMS</a>, <a class="el" href="classprf_1_1Hydrophobicity.html#a525be988113d4e258a0faead5269035f">prf::Hydrophobicity</a>, and <a class="el" href="classprf_1_1LocExVol.html#a9ec19204975fd6203e87974a268ac7da">prf::LocExVol</a>.</p>

</div>
</div>
<a class="anchor" id="a1036bde92a6b425afb03edc6243791ad"></a><!-- doxytag: member="prf::Energy::delta" ref="a1036bde92a6b425afb03edc6243791ad" args="(Update *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::Energy::delta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf_1_1Update.html">Update</a> *&nbsp;</td>
          <td class="paramname"> <em>u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Estimate how much the value will change due to the a given update. Quite often it is possible to estimate the change in the value of an <a class="el" href="classprf_1_1Observable.html" title="An observable is in principle anything that is named and has a value.">Observable</a> due to such an <a class="el" href="classprf_1_1MC.html" title="MC class handles the Markov Chain Monte Carlo evolution.">MC</a> update at a much smaller computational cost than evaluating the <a class="el" href="classprf_1_1Observable.html" title="An observable is in principle anything that is named and has a value.">Observable</a> from scratch.</p>
<p>This function assumes that the observable was evaluated at one state of the population, and the update passed as argument was performed on that state of the population. It is also ok if the state of the population is only changed with <a class="el" href="classprf_1_1MC.html" title="MC class handles the Markov Chain Monte Carlo evolution.">MC</a> updates and the accept or reject function is called for each accepted or rejected update.</p>
<p>Except for energy classes in ProFASi, the other Observables are not evaluated or kept up to date during an <a class="el" href="classprf_1_1MC.html" title="MC class handles the Markov Chain Monte Carlo evolution.">MC</a> sweep. For such variables this delta function only returns something useful immediately after an evaluate call. </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Observable.html#a7f91d559128b1a271c60608e72f9e12a">prf::Observable</a>.</p>

</div>
</div>
<a class="anchor" id="a2858fcc4d2cfa0823fada58915b8797a"></a><!-- doxytag: member="prf::Energy::deltaEwithlimit" ref="a2858fcc4d2cfa0823fada58915b8797a" args="(Update *updt, double maxde)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::Energy::deltaEwithlimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf_1_1Update.html">Update</a> *&nbsp;</td>
          <td class="paramname"> <em>updt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>maxde</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function contains one of the interesting speed-up tricks of ProFASi. In Markov chain Monte Carlo simulations, there is an acceptance criterion, which depends, on energy changes, temperature a random number etc. Often, it is possible to calculate everything other than the energy change before proceeding to the energy change calculations. This means, before starting out to find how much the energy changed, we can figure out the maximum acceptable total energy change. We then isolate the most expensive contribution and calculate the regular delta E for all other terms, and subtract from the maximum total acceptable change, and get a value for the maximum allowed value for the last and most expensive term. We pass this value to the delta E calculation of the last term, using this function. Implementation of that energy function is allowed to abort its calculation, if at some point during its calculation, it can determine that there is no way to stay below the given limit. This means, this function is allowed to return any (wrong) value greater than maxde, if the correct value is also greater than maxde with certainty. It is understood that the update will be rejected if a value greater than maxde is returned.</p>
<p>As an example, consider the situation when the most expensive term is positive definite. We start by calculating the contributions of the moved atoms before the update. Then while calculating the contributions of the same atoms after the update, if after 5 of the 2000 terms, the partial sum exceeds a limit, there is no point in calculating the remaining contributions, which can not bring the total change below maxde. This trick makes a noticeable impact on the execution speed. Like deltaE, but stop if change exceeds a given limit </p>

<p>Reimplemented in <a class="el" href="classprf_1_1ExVol.html#a85c7d7d381e2d2201f6664e7dd93460b">prf::ExVol</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d1ee6ac6344ddd86ac15b8a3b69b19"></a><!-- doxytag: member="prf::Energy::evaluate" ref="ab9d1ee6ac6344ddd86ac15b8a3b69b19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::Energy::evaluate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>do a new ab initio calculation </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Observable.html#a1b43842e0f9cc2eea0f7d2a520a335bd">prf::Observable</a>.</p>

<p>Reimplemented in <a class="el" href="classprf_1_1Bias.html#afb2dd9f545d891688825cac4fbae0df7">prf::Bias</a>, <a class="el" href="classprf_1_1ChargedSCInteraction.html#afa9e106ed2ce4aa1df4786d67756b2a9">prf::ChargedSCInteraction</a>, <a class="el" href="classprf_1_1DihedralRestraints.html#a81a10241390d0573ca5107b751af3595">prf::DihedralRestraints</a>, <a class="el" href="classprf_1_1DistanceRestraints.html#aa48d8b344a8b93b4ef1369418f9dbffd">prf::DistanceRestraints</a>, <a class="el" href="classprf_1_1ObsEnergy.html#ae705b9ba61828bb4a91f1ac089bb54e8">prf::ObsEnergy</a>, <a class="el" href="classprf_1_1ExVol.html#af14b6dc10ac70a7c0bde812830418775">prf::ExVol</a>, <a class="el" href="classprf_1_1HBMM.html#af9e93175154c50a47f9fde10cdcaa3f0">prf::HBMM</a>, <a class="el" href="classprf_1_1HBMS.html#a25a68a22b7b882ab05836639ed5e8f1c">prf::HBMS</a>, <a class="el" href="classprf_1_1Hydrophobicity.html#ad3ca683c15ddf635c035836fd6a00ca0">prf::Hydrophobicity</a>, <a class="el" href="classprf_1_1LocExVol.html#a0761d5c1ce2d4dbcaa0e977c8d69e773">prf::LocExVol</a>, and <a class="el" href="classprf_1_1TorsionTerm.html#a3502725a9ad964ce1e3ddc74ec83842e">prf::TorsionTerm</a>.</p>

</div>
</div>
<a class="anchor" id="a5048a7d6604c288cb8ef62f94e6030c8"></a><!-- doxytag: member="prf::Energy::init_obs" ref="a5048a7d6604c288cb8ef62f94e6030c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int prf::Energy::init_obs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Even if it seems that one particular observable might need additional arguments during initialization, it is advantageous to have a uniform syntax for all of them. So, when additional arguments are needed, one should provide them in a separate function called before initialization, and then call init_obs without arguments. The name init_obs instead of a more natural "init" or "initialize" is because an <a class="el" href="classprf_1_1Observable.html" title="An observable is in principle anything that is named and has a value.">Observable</a> often inherits from other classes which represent its character more fundamentally. So, the names such as "init" are kept free for such base classes. </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Observable.html#a75c0338181f981847cc1d45e1e8a58b8">prf::Observable</a>.</p>

</div>
</div>
<a class="anchor" id="acb8ea3b9fba3fd8c82f2efcc6695c38f"></a><!-- doxytag: member="prf::Energy::rangeEstimate" ref="acb8ea3b9fba3fd8c82f2efcc6695c38f" args="(double &amp;x1, double &amp;x2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::Energy::rangeEstimate </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default is between 0 and 1. So, for observables with values always between 0 and 1, you need not over-write this virtual function. Sometimes the observable will have a different fixed range, determined by its definition. Sometimes the range can not be determined perfectly. In such a case, let this function just return something reasonable. </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Observable.html#a163e5d4537c59608a1c44c4b6bd80f75">prf::Observable</a>.</p>

<p>Reimplemented in <a class="el" href="classprf_1_1Bias.html#a859dfee5fef73b4d1e84c8631aeac70a">prf::Bias</a>, <a class="el" href="classprf_1_1ChargedSCInteraction.html#a448afcf25b696bf3ffac149d21fca214">prf::ChargedSCInteraction</a>, <a class="el" href="classprf_1_1DihedralRestraints.html#ac89e080073b556af8ca18c2a4fd30c59">prf::DihedralRestraints</a>, <a class="el" href="classprf_1_1DistanceRestraints.html#aa2396ce5c4a4a4127586c0ce9b10b3bc">prf::DistanceRestraints</a>, <a class="el" href="classprf_1_1ObsEnergy.html#a9c2046bd2b37d6dcf1653607a49f4f92">prf::ObsEnergy</a>, <a class="el" href="classprf_1_1ExVol.html#a141889b5b66ad692068c01e19edf19ef">prf::ExVol</a>, <a class="el" href="classprf_1_1HBMM.html#a794ffeec87ddb87d6d2086d4b0b36258">prf::HBMM</a>, <a class="el" href="classprf_1_1HBMS.html#a710ff7502e613976f8e70801cf10eb9c">prf::HBMS</a>, <a class="el" href="classprf_1_1Hydrophobicity.html#afb9c03650476dd93bc782d7764847601">prf::Hydrophobicity</a>, <a class="el" href="classprf_1_1LocExVol.html#ab9cacc72f877310dcd736a9e6e32813b">prf::LocExVol</a>, and <a class="el" href="classprf_1_1TorsionTerm.html#a49d87ad890302c9b510d82c47ec8c28a">prf::TorsionTerm</a>.</p>

</div>
</div>
<a class="anchor" id="a4d10b1991e8b78c2b167fbf18205b0a5"></a><!-- doxytag: member="prf::Energy::set_pars" ref="a4d10b1991e8b78c2b167fbf18205b0a5" args="(std::string pars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::Energy::set_pars </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>pars</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function provides a unified mechanism to adjust parameters in an energy term. What parameters it might make sense to adjust depends on the energy term. If the energy term is a pseudo-energy implementing <a class="el" href="classprf_1_1RMSD.html" title="Root Mean Square Deviation.">RMSD</a> constraints relative to a structure abc.pdb, the name of the structure file should be an easily adjustible parameter rather than a hard coded string. The H--O distance in a hydrogen bond, on the other hand, is less useful as an adjustible parameter. It is up to the individual derived classes to do what they like with the requested parameter changes. The base class ignores the parameter requests. </p>

<p>Reimplemented in <a class="el" href="classprf_1_1DihedralRestraints.html#aab78d885556f7e3da0344721b5f5d948">prf::DihedralRestraints</a>, <a class="el" href="classprf_1_1DistanceRestraints.html#ac55b450e5759c329b69a0457b43186dd">prf::DistanceRestraints</a>, and <a class="el" href="classprf_1_1ObsEnergy.html#a2a5abc1ac0e79091ac931551ea90032c">prf::ObsEnergy</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/Energy/Energy.hh</li>
<li>model/Energy/Energy.cc</li>
</ul>
</div>
<center>
<hr>
<small>
<strong>PROFASI: Protein Folding and Aggregation Simulator, Version 1.5 
</strong><br />
&copy; (2005-2009) <a href="http://www.thep.lu.se/~anders">Anders Irb&auml;ck</a>
and <a href="http://www.thep.lu.se/~sandipan">Sandipan Mohanty</a><br />
Documentation generated on 19 Jun 2014 using Doxygen version 1.6.1
</small>
</center>

</body>
</html> 
