<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PROFASI: prf::ExVol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceprf.html">prf</a>::<a class="el" href="classprf_1_1ExVol.html">ExVol</a>
  </div>
</div>
<div class="contents">
<h1>prf::ExVol Class Reference<br/>
<small>
[<a class="el" href="group__profasi__energies.html">Energy Classes</a>]</small>
</h1><!-- doxytag: class="prf::ExVol" --><!-- doxytag: inherits="prf::ExVolBase,prf::Energy" -->
<p>The excluded volume term.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ExVol.hh&gt;</code></p>

<p>Inherits <a class="el" href="classprf_1_1ExVolBase.html">prf::ExVolBase</a>, and <a class="el" href="classprf_1_1Energy.html">prf::Energy</a>.</p>

<p><a href="classprf_1_1ExVol-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#a141889b5b66ad692068c01e19edf19ef">rangeEstimate</a> (double &amp;x1, double &amp;x2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate a range in which values of this observable are expected.  <a href="#a141889b5b66ad692068c01e19edf19ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#af14b6dc10ac70a7c0bde812830418775">evaluate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92418636958f22d744e98c8c0e5d9973"></a><!-- doxytag: member="prf::ExVol::deltaE" ref="a92418636958f22d744e98c8c0e5d9973" args="(Update *)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#a92418636958f22d744e98c8c0e5d9973">deltaE</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">do a new delta calculation optimized for the given kind of update <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#a85c7d7d381e2d2201f6664e7dd93460b">deltaEwithlimit</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *updt, double emax)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate energy change for an update, but with a stop condition.  <a href="#a85c7d7d381e2d2201f6664e7dd93460b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#a4fd027c1ac9303dedcfad13f2fb51975">Accept</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a proposed update.  <a href="#a4fd027c1ac9303dedcfad13f2fb51975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaac7ef63f2140f55158b13c739dc32c3"></a><!-- doxytag: member="prf::ExVol::Revert" ref="aaac7ef63f2140f55158b13c739dc32c3" args="(Update *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#aaac7ef63f2140f55158b13c739dc32c3">Revert</a> (<a class="el" href="classprf_1_1Update.html">Update</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reject a proposed update. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprf_1_1ExVol.html#ad5b6f71b14c7fe4fa4c761597ef92a25">PairType</a> (int i, int j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Categorizes different kinds of pairs of atoms.  <a href="#ad5b6f71b14c7fe4fa4c761597ef92a25"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class represents the excluded volume interactions and is the most painstakingly optimized part of PROFASI. A backup matrix, as used for other energy terms would not be very effective, because almost every pair of atoms can interact with this term. The optimization is achieved using the following ...</p>
<ol>
<li>
Since the model assumes fixed bond lengths and bond angles, there are many pairs of atoms with fixed separation. Excluded volume contribution from such pairs is dynamically uninteresting and is set to zero.  </li>
<li>
<a class="el" href="classprf_1_1Atom.html" title="Representation of an atom in PROFASI.">Atom</a> pairs separated by 3 covalent bonds are treated separately in the <a class="el" href="classprf_1_1LocExVol.html" title="Third-neighbour excluded volume contribution.">LocExVol</a> class  </li>
<li>
The excluded volume potential in the model is a strong repulsion with a finite range. So, the periodic box for the whole system is divided into cells with linear dimensions greater than or equal to the range of the excluded volume potential. Each atom is assigned a cell. <a class="el" href="classprf_1_1Atom.html" title="Representation of an atom in PROFASI.">Atom</a> pairs which are neither in the same cell nor in neighbouring cells would have distances greater than the range of the potential, and hence wont contribute. So, during evaluation, such pairs are ignored. For each atom, contribution from other atoms in the same cell and in the neighbouring cells is calculated. For each update, the cell-assignment is carefully updated, so that only the moved atoms are re-assigned. <a class="el" href="classprf_1_1Energy.html" title="Energy base class.">Energy</a> contributions are recalculated only on "active" cells, in which something happened: atoms moved in or moved out of the cell or one of its neighbours.  </li>
</ol>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4fd027c1ac9303dedcfad13f2fb51975"></a><!-- doxytag: member="prf::ExVol::Accept" ref="a4fd027c1ac9303dedcfad13f2fb51975" args="(Update *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::ExVol::Accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf_1_1Update.html">Update</a> *&nbsp;</td>
          <td class="paramname"> <em>updt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PROFASI uses many local contribution matrices and backup variables to quickly evaluate the change caused to any energy term by a given update. Those backup variables and the contribution matrices need to be kept in sync with the current system configuration. So, each energy class has an accept and a reject method, which are called when an update is accepted or rejected. What is done inside these functions depends on the energy term and optimization trick used therein. </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Energy.html#ac02fa5cca1cc393bf8357f7091e32e46">prf::Energy</a>.</p>

</div>
</div>
<a class="anchor" id="a85c7d7d381e2d2201f6664e7dd93460b"></a><!-- doxytag: member="prf::ExVol::deltaEwithlimit" ref="a85c7d7d381e2d2201f6664e7dd93460b" args="(Update *updt, double emax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::ExVol::deltaEwithlimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classprf_1_1Update.html">Update</a> *&nbsp;</td>
          <td class="paramname"> <em>updt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>maxde</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function contains one of the interesting speed-up tricks of ProFASi. In Markov chain Monte Carlo simulations, there is an acceptance criterion, which depends, on energy changes, temperature a random number etc. Often, it is possible to calculate everything other than the energy change before proceeding to the energy change calculations. This means, before starting out to find how much the energy changed, we can figure out the maximum acceptable total energy change. We then isolate the most expensive contribution and calculate the regular delta E for all other terms, and subtract from the maximum total acceptable change, and get a value for the maximum allowed value for the last and most expensive term. We pass this value to the delta E calculation of the last term, using this function. Implementation of that energy function is allowed to abort its calculation, if at some point during its calculation, it can determine that there is no way to stay below the given limit. This means, this function is allowed to return any (wrong) value greater than maxde, if the correct value is also greater than maxde with certainty. It is understood that the update will be rejected if a value greater than maxde is returned.</p>
<p>As an example, consider the situation when the most expensive term is positive definite. We start by calculating the contributions of the moved atoms before the update. Then while calculating the contributions of the same atoms after the update, if after 5 of the 2000 terms, the partial sum exceeds a limit, there is no point in calculating the remaining contributions, which can not bring the total change below maxde. This trick makes a noticeable impact on the execution speed. Like deltaE, but stop if change exceeds a given limit </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Energy.html#a2858fcc4d2cfa0823fada58915b8797a">prf::Energy</a>.</p>

</div>
</div>
<a class="anchor" id="af14b6dc10ac70a7c0bde812830418775"></a><!-- doxytag: member="prf::ExVol::evaluate" ref="af14b6dc10ac70a7c0bde812830418775" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prf::ExVol::evaluate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>do a new ab initio calculation </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Energy.html#ab9d1ee6ac6344ddd86ac15b8a3b69b19">prf::Energy</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b6f71b14c7fe4fa4c761597ef92a25"></a><!-- doxytag: member="prf::ExVol::PairType" ref="ad5b6f71b14c7fe4fa4c761597ef92a25" args="(int i, int j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int prf::ExVol::PairType </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If NA is the number of types of atoms (5 in our case, H, C, N, O, S), there are NA*NA kinds of pairs. This information is used to pre-calculate the unchanging parts of the functional form of excluded volume, and only insert the distance information for a new configuration when required. So, the function PairType(i,j) here, returns numbers between -1 and 25. 0-24 for all kinds of pairs. -1 means "don't care", and is returned when there is less than or equal to three covalent bonds between them. With 1 or 2 bonds, the distance between the pair can not change in the model. For 3 covalent bonds, the excluded volume is calculated separately in the <a class="el" href="classprf_1_1LocExVol.html" title="Third-neighbour excluded volume contribution.">LocExVol</a> class. </p>

</div>
</div>
<a class="anchor" id="a141889b5b66ad692068c01e19edf19ef"></a><!-- doxytag: member="prf::ExVol::rangeEstimate" ref="a141889b5b66ad692068c01e19edf19ef" args="(double &amp;x1, double &amp;x2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prf::ExVol::rangeEstimate </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default is between 0 and 1. So, for observables with values always between 0 and 1, you need not over-write this virtual function. Sometimes the observable will have a different fixed range, determined by its definition. Sometimes the range can not be determined perfectly. In such a case, let this function just return something reasonable. </p>

<p>Reimplemented from <a class="el" href="classprf_1_1Energy.html#acb8ea3b9fba3fd8c82f2efcc6695c38f">prf::Energy</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/Energy/ExVol.hh</li>
<li>model/Energy/ExVol.cc</li>
</ul>
</div>
<center>
<hr>
<small>
<strong>PROFASI: Protein Folding and Aggregation Simulator, Version 1.5 
</strong><br />
&copy; (2005-2009) <a href="http://www.thep.lu.se/~anders">Anders Irb&auml;ck</a>
and <a href="http://www.thep.lu.se/~sandipan">Sandipan Mohanty</a><br />
Documentation generated on 19 Jun 2014 using Doxygen version 1.6.1
</small>
</center>

</body>
</html> 
